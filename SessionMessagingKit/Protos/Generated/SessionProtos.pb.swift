// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SessionProtos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// iOS - since we use a modern proto-compiler, we must specify the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SessionProtos_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_Envelope.TypeEnum {
    get {return _type ?? .sessionMessage}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var sourceDevice: UInt32 {
    get {return _sourceDevice ?? 0}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {self._sourceDevice = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var content: Data {
    get {return _content ?? Data()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var serverTimestamp: UInt64 {
    get {return _serverTimestamp ?? 0}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sessionMessage // = 6
    case closedGroupMessage // = 7

    init() {
      self = .sessionMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 6: self = .sessionMessage
      case 7: self = .closedGroupMessage
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .sessionMessage: return 6
      case .closedGroupMessage: return 7
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_Envelope.TypeEnum? = nil
  fileprivate var _source: String? = nil
  fileprivate var _sourceDevice: UInt32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _content: Data? = nil
  fileprivate var _serverTimestamp: UInt64? = nil
}

#if swift(>=4.2)

extension SessionProtos_Envelope.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_TypingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var action: SessionProtos_TypingMessage.Action {
    get {return _action ?? .started}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case started // = 0
    case stopped // = 1

    init() {
      self = .started
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .started
      case 1: self = .stopped
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .started: return 0
      case .stopped: return 1
      }
    }

  }

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _action: SessionProtos_TypingMessage.Action? = nil
}

#if swift(>=4.2)

extension SessionProtos_TypingMessage.Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_UnsendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _author: String? = nil
}

struct SessionProtos_MessageRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var isApproved: Bool {
    get {return _isApproved ?? false}
    set {_isApproved = newValue}
  }
  /// Returns true if `isApproved` has been explicitly set.
  var hasIsApproved: Bool {return self._isApproved != nil}
  /// Clears the value of `isApproved`. Subsequent reads from it will return its default value.
  mutating func clearIsApproved() {self._isApproved = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var profile: SessionProtos_LokiProfile {
    get {return _profile ?? SessionProtos_LokiProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  mutating func clearProfile() {self._profile = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isApproved: Bool? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _profile: SessionProtos_LokiProfile? = nil
}

struct SessionProtos_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMessage: SessionProtos_DataMessage {
    get {return _storage._dataMessage ?? SessionProtos_DataMessage()}
    set {_uniqueStorage()._dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return _storage._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {_uniqueStorage()._dataMessage = nil}

  var callMessage: SessionProtos_CallMessage {
    get {return _storage._callMessage ?? SessionProtos_CallMessage()}
    set {_uniqueStorage()._callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return _storage._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {_uniqueStorage()._callMessage = nil}

  var receiptMessage: SessionProtos_ReceiptMessage {
    get {return _storage._receiptMessage ?? SessionProtos_ReceiptMessage()}
    set {_uniqueStorage()._receiptMessage = newValue}
  }
  /// Returns true if `receiptMessage` has been explicitly set.
  var hasReceiptMessage: Bool {return _storage._receiptMessage != nil}
  /// Clears the value of `receiptMessage`. Subsequent reads from it will return its default value.
  mutating func clearReceiptMessage() {_uniqueStorage()._receiptMessage = nil}

  var typingMessage: SessionProtos_TypingMessage {
    get {return _storage._typingMessage ?? SessionProtos_TypingMessage()}
    set {_uniqueStorage()._typingMessage = newValue}
  }
  /// Returns true if `typingMessage` has been explicitly set.
  var hasTypingMessage: Bool {return _storage._typingMessage != nil}
  /// Clears the value of `typingMessage`. Subsequent reads from it will return its default value.
  mutating func clearTypingMessage() {_uniqueStorage()._typingMessage = nil}

  var dataExtractionNotification: SessionProtos_DataExtractionNotification {
    get {return _storage._dataExtractionNotification ?? SessionProtos_DataExtractionNotification()}
    set {_uniqueStorage()._dataExtractionNotification = newValue}
  }
  /// Returns true if `dataExtractionNotification` has been explicitly set.
  var hasDataExtractionNotification: Bool {return _storage._dataExtractionNotification != nil}
  /// Clears the value of `dataExtractionNotification`. Subsequent reads from it will return its default value.
  mutating func clearDataExtractionNotification() {_uniqueStorage()._dataExtractionNotification = nil}

  var unsendRequest: SessionProtos_UnsendRequest {
    get {return _storage._unsendRequest ?? SessionProtos_UnsendRequest()}
    set {_uniqueStorage()._unsendRequest = newValue}
  }
  /// Returns true if `unsendRequest` has been explicitly set.
  var hasUnsendRequest: Bool {return _storage._unsendRequest != nil}
  /// Clears the value of `unsendRequest`. Subsequent reads from it will return its default value.
  mutating func clearUnsendRequest() {_uniqueStorage()._unsendRequest = nil}

  var messageRequestResponse: SessionProtos_MessageRequestResponse {
    get {return _storage._messageRequestResponse ?? SessionProtos_MessageRequestResponse()}
    set {_uniqueStorage()._messageRequestResponse = newValue}
  }
  /// Returns true if `messageRequestResponse` has been explicitly set.
  var hasMessageRequestResponse: Bool {return _storage._messageRequestResponse != nil}
  /// Clears the value of `messageRequestResponse`. Subsequent reads from it will return its default value.
  mutating func clearMessageRequestResponse() {_uniqueStorage()._messageRequestResponse = nil}

  var expirationType: SessionProtos_Content.ExpirationType {
    get {return _storage._expirationType ?? .unknown}
    set {_uniqueStorage()._expirationType = newValue}
  }
  /// Returns true if `expirationType` has been explicitly set.
  var hasExpirationType: Bool {return _storage._expirationType != nil}
  /// Clears the value of `expirationType`. Subsequent reads from it will return its default value.
  mutating func clearExpirationType() {_uniqueStorage()._expirationType = nil}

  var expirationTimer: UInt32 {
    get {return _storage._expirationTimer ?? 0}
    set {_uniqueStorage()._expirationTimer = newValue}
  }
  /// Returns true if `expirationTimer` has been explicitly set.
  var hasExpirationTimer: Bool {return _storage._expirationTimer != nil}
  /// Clears the value of `expirationTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimer() {_uniqueStorage()._expirationTimer = nil}

  /// NOTE: This timestamp was added to address the issue with 1o1 message envelope timestamps were
  /// unauthenticated because 1o1 messages encrypt the Content not the envelope. In Groups, the
  /// entire envelope is encrypted and hence can be trusted.
  var sigTimestamp: UInt64 {
    get {return _storage._sigTimestamp ?? 0}
    set {_uniqueStorage()._sigTimestamp = newValue}
  }
  /// Returns true if `sigTimestamp` has been explicitly set.
  var hasSigTimestamp: Bool {return _storage._sigTimestamp != nil}
  /// Clears the value of `sigTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSigTimestamp() {_uniqueStorage()._sigTimestamp = nil}

  var proMessage: SessionProtos_ProMessage {
    get {return _storage._proMessage ?? SessionProtos_ProMessage()}
    set {_uniqueStorage()._proMessage = newValue}
  }
  /// Returns true if `proMessage` has been explicitly set.
  var hasProMessage: Bool {return _storage._proMessage != nil}
  /// Clears the value of `proMessage`. Subsequent reads from it will return its default value.
  mutating func clearProMessage() {_uniqueStorage()._proMessage = nil}

  /// NOTE: Temporary transition field to include the pro-signature into Content for community
  /// messages to use.
  ///
  /// Community messages are currently sent and received as plaintext Content. We call this state of
  /// the network v0.
  ///
  /// We will continue to send Community messages using the Content structure, but, now enhanced with
  /// the optional `proSigForCommunityMessageOnly` field which contains the pro signature. We call
  /// this network v1. The new clients running v1 will pack the pro-signature into the payload. We
  /// maintain forwards compatibility with clients on v0 as we are still sending content
  /// on the wire, they skip the new pro data.
  ///
  /// Simultaneously in v1 the responsibility of parsing the open groups messages will go into
  /// libsession. Libsession will be setup to try and parse the open groups message as a `Content`
  /// message at first, if that fails it will try to read the community message as an `Envelope`.
  /// In summary in a v1 network:
  ///
  ///   v0 will still receive messages from v1 as they send `Content` community messages.
  ///
  ///   v1 accepts v0 (`Content`) and v1 (`Envelope`) on the wire for community messages. v1 sends
  ///   `Content` community messages so that there's compatibility with v0.
  ///
  /// After a defined transitionary period, we create a new release and update libsession to stop
  /// sending `Content` for communities and transition to sending `Envelope` for messages. We mark
  /// this as a v2 network:
  ///
  ///   v0 will still receive messages from v1 (`Content`) but not v2 (`Envelope`) community
  ///   messages.
  ///
  ///   v1 accepts v0 (`Content`) and v1 (`Envelope`) on the wire for community messages. v1 sends
  ///   `Content` community messages so that there's compatibility with v0.
  ///
  ///   v2 swaps the parsing order. it tries parsing v1 (`envelope`) then v0 (`content`) from a
  ///   community message. v2 sends `envelope` community messages so compatbility is maintained with
  ///   v1 but not v0.
  ///
  /// After a final transitionary period, v3, remove parsing content entirely from libsession for
  /// community messages and removes the pro-signature from `content`. in this final stage, v2 and v3
  /// are the final set of clients that can continue to talk to each other.
  ///
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  /// | Version | Sends          | Receives v0 | Receives v1      | Receives v2 | Receives v3 |
  /// |         |                | (Content)   | (Content+ProSig) | (Envelope)  | (Envelope)  |
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  /// | v0      | Content        | Yes         | Yes              | No          | No          |
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  /// | v1      | Content+ProSig | Yes         | Yes              | Yes         | Yes         |
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  /// | v2      | Envelope       | Yes         | Yes              | Yes         | Yes         |
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  /// | v3      | Envelope       | No          | No               | Yes         | Yes         |
  /// +---------+----------------+-------------+------------------+-------------+-------------+
  var proSigForCommunityMessageOnly: Data {
    get {return _storage._proSigForCommunityMessageOnly ?? Data()}
    set {_uniqueStorage()._proSigForCommunityMessageOnly = newValue}
  }
  /// Returns true if `proSigForCommunityMessageOnly` has been explicitly set.
  var hasProSigForCommunityMessageOnly: Bool {return _storage._proSigForCommunityMessageOnly != nil}
  /// Clears the value of `proSigForCommunityMessageOnly`. Subsequent reads from it will return its default value.
  mutating func clearProSigForCommunityMessageOnly() {_uniqueStorage()._proSigForCommunityMessageOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ExpirationType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case deleteAfterRead // = 1
    case deleteAfterSend // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .deleteAfterRead
      case 2: self = .deleteAfterSend
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .deleteAfterRead: return 1
      case .deleteAfterSend: return 2
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SessionProtos_Content.ExpirationType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_CallMessage.TypeEnum {
    get {return _type ?? .preOffer}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var sdps: [String] = []

  var sdpMlineIndexes: [UInt32] = []

  var sdpMids: [String] = []

  /// @required
  var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case preOffer // = 6
    case offer // = 1
    case answer // = 2
    case provisionalAnswer // = 3
    case iceCandidates // = 4
    case endCall // = 5

    init() {
      self = .preOffer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .offer
      case 2: self = .answer
      case 3: self = .provisionalAnswer
      case 4: self = .iceCandidates
      case 5: self = .endCall
      case 6: self = .preOffer
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .offer: return 1
      case .answer: return 2
      case .provisionalAnswer: return 3
      case .iceCandidates: return 4
      case .endCall: return 5
      case .preOffer: return 6
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_CallMessage.TypeEnum? = nil
  fileprivate var _uuid: String? = nil
}

#if swift(>=4.2)

extension SessionProtos_CallMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_KeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// @required
  var privateKey: Data {
    get {return _privateKey ?? Data()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _privateKey: Data? = nil
}

struct SessionProtos_DataExtractionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_DataExtractionNotification.TypeEnum {
    get {return _type ?? .screenshot}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case screenshot // = 1

    /// timestamp
    case mediaSaved // = 2

    init() {
      self = .screenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .screenshot
      case 2: self = .mediaSaved
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .screenshot: return 1
      case .mediaSaved: return 2
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_DataExtractionNotification.TypeEnum? = nil
  fileprivate var _timestamp: UInt64? = nil
}

#if swift(>=4.2)

extension SessionProtos_DataExtractionNotification.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_LokiProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayName: String {
    get {return _displayName ?? String()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {self._displayName = nil}

  var profilePicture: String {
    get {return _profilePicture ?? String()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  mutating func clearProfilePicture() {self._profilePicture = nil}

  /// Timestamp of the last profile update
  var lastUpdateSeconds: UInt64 {
    get {return _lastUpdateSeconds ?? 0}
    set {_lastUpdateSeconds = newValue}
  }
  /// Returns true if `lastUpdateSeconds` has been explicitly set.
  var hasLastUpdateSeconds: Bool {return self._lastUpdateSeconds != nil}
  /// Clears the value of `lastUpdateSeconds`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdateSeconds() {self._lastUpdateSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _displayName: String? = nil
  fileprivate var _profilePicture: String? = nil
  fileprivate var _lastUpdateSeconds: UInt64? = nil
}

struct SessionProtos_DataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: String {
    get {return _storage._body ?? String()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var attachments: [SessionProtos_AttachmentPointer] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  /// optional uint32                 expireTimer                    = 5;  // No longer used
  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var quote: SessionProtos_DataMessage.Quote {
    get {return _storage._quote ?? SessionProtos_DataMessage.Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  var preview: [SessionProtos_DataMessage.Preview] {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  var reaction: SessionProtos_DataMessage.Reaction {
    get {return _storage._reaction ?? SessionProtos_DataMessage.Reaction()}
    set {_uniqueStorage()._reaction = newValue}
  }
  /// Returns true if `reaction` has been explicitly set.
  var hasReaction: Bool {return _storage._reaction != nil}
  /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
  mutating func clearReaction() {_uniqueStorage()._reaction = nil}

  var profile: SessionProtos_LokiProfile {
    get {return _storage._profile ?? SessionProtos_LokiProfile()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  mutating func clearProfile() {_uniqueStorage()._profile = nil}

  var openGroupInvitation: SessionProtos_DataMessage.OpenGroupInvitation {
    get {return _storage._openGroupInvitation ?? SessionProtos_DataMessage.OpenGroupInvitation()}
    set {_uniqueStorage()._openGroupInvitation = newValue}
  }
  /// Returns true if `openGroupInvitation` has been explicitly set.
  var hasOpenGroupInvitation: Bool {return _storage._openGroupInvitation != nil}
  /// Clears the value of `openGroupInvitation`. Subsequent reads from it will return its default value.
  mutating func clearOpenGroupInvitation() {_uniqueStorage()._openGroupInvitation = nil}

  var syncTarget: String {
    get {return _storage._syncTarget ?? String()}
    set {_uniqueStorage()._syncTarget = newValue}
  }
  /// Returns true if `syncTarget` has been explicitly set.
  var hasSyncTarget: Bool {return _storage._syncTarget != nil}
  /// Clears the value of `syncTarget`. Subsequent reads from it will return its default value.
  mutating func clearSyncTarget() {_uniqueStorage()._syncTarget = nil}

  var blocksCommunityMessageRequests: Bool {
    get {return _storage._blocksCommunityMessageRequests ?? false}
    set {_uniqueStorage()._blocksCommunityMessageRequests = newValue}
  }
  /// Returns true if `blocksCommunityMessageRequests` has been explicitly set.
  var hasBlocksCommunityMessageRequests: Bool {return _storage._blocksCommunityMessageRequests != nil}
  /// Clears the value of `blocksCommunityMessageRequests`. Subsequent reads from it will return its default value.
  mutating func clearBlocksCommunityMessageRequests() {_uniqueStorage()._blocksCommunityMessageRequests = nil}

  var groupUpdateMessage: SessionProtos_GroupUpdateMessage {
    get {return _storage._groupUpdateMessage ?? SessionProtos_GroupUpdateMessage()}
    set {_uniqueStorage()._groupUpdateMessage = newValue}
  }
  /// Returns true if `groupUpdateMessage` has been explicitly set.
  var hasGroupUpdateMessage: Bool {return _storage._groupUpdateMessage != nil}
  /// Clears the value of `groupUpdateMessage`. Subsequent reads from it will return its default value.
  mutating func clearGroupUpdateMessage() {_uniqueStorage()._groupUpdateMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case expirationTimerUpdate // = 2

    init() {
      self = .expirationTimerUpdate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 2: self = .expirationTimerUpdate
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .expirationTimerUpdate: return 2
      }
    }

  }

  struct Quote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// @required
    var author: String {
      get {return _author ?? String()}
      set {_author = newValue}
    }
    /// Returns true if `author` has been explicitly set.
    var hasAuthor: Bool {return self._author != nil}
    /// Clears the value of `author`. Subsequent reads from it will return its default value.
    mutating func clearAuthor() {self._author = nil}

    var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var attachments: [SessionProtos_DataMessage.Quote.QuotedAttachment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct QuotedAttachment {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var contentType: String {
        get {return _contentType ?? String()}
        set {_contentType = newValue}
      }
      /// Returns true if `contentType` has been explicitly set.
      var hasContentType: Bool {return self._contentType != nil}
      /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
      mutating func clearContentType() {self._contentType = nil}

      var fileName: String {
        get {return _fileName ?? String()}
        set {_fileName = newValue}
      }
      /// Returns true if `fileName` has been explicitly set.
      var hasFileName: Bool {return self._fileName != nil}
      /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
      mutating func clearFileName() {self._fileName = nil}

      var thumbnail: SessionProtos_AttachmentPointer {
        get {return _thumbnail ?? SessionProtos_AttachmentPointer()}
        set {_thumbnail = newValue}
      }
      /// Returns true if `thumbnail` has been explicitly set.
      var hasThumbnail: Bool {return self._thumbnail != nil}
      /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
      mutating func clearThumbnail() {self._thumbnail = nil}

      var flags: UInt32 {
        get {return _flags ?? 0}
        set {_flags = newValue}
      }
      /// Returns true if `flags` has been explicitly set.
      var hasFlags: Bool {return self._flags != nil}
      /// Clears the value of `flags`. Subsequent reads from it will return its default value.
      mutating func clearFlags() {self._flags = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Flags: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case voiceMessage // = 1

        init() {
          self = .voiceMessage
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 1: self = .voiceMessage
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .voiceMessage: return 1
          }
        }

      }

      init() {}

      fileprivate var _contentType: String? = nil
      fileprivate var _fileName: String? = nil
      fileprivate var _thumbnail: SessionProtos_AttachmentPointer? = nil
      fileprivate var _flags: UInt32? = nil
    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _author: String? = nil
    fileprivate var _text: String? = nil
  }

  struct Preview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var title: String {
      get {return _title ?? String()}
      set {_title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    var hasTitle: Bool {return self._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    mutating func clearTitle() {self._title = nil}

    var image: SessionProtos_AttachmentPointer {
      get {return _image ?? SessionProtos_AttachmentPointer()}
      set {_image = newValue}
    }
    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool {return self._image != nil}
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() {self._image = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: String? = nil
    fileprivate var _title: String? = nil
    fileprivate var _image: SessionProtos_AttachmentPointer? = nil
  }

  struct Reaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// @required
    var author: String {
      get {return _author ?? String()}
      set {_author = newValue}
    }
    /// Returns true if `author` has been explicitly set.
    var hasAuthor: Bool {return self._author != nil}
    /// Clears the value of `author`. Subsequent reads from it will return its default value.
    mutating func clearAuthor() {self._author = nil}

    var emoji: String {
      get {return _emoji ?? String()}
      set {_emoji = newValue}
    }
    /// Returns true if `emoji` has been explicitly set.
    var hasEmoji: Bool {return self._emoji != nil}
    /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
    mutating func clearEmoji() {self._emoji = nil}

    /// @required
    var action: SessionProtos_DataMessage.Reaction.Action {
      get {return _action ?? .react}
      set {_action = newValue}
    }
    /// Returns true if `action` has been explicitly set.
    var hasAction: Bool {return self._action != nil}
    /// Clears the value of `action`. Subsequent reads from it will return its default value.
    mutating func clearAction() {self._action = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Action: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case react // = 0
      case remove // = 1

      init() {
        self = .react
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .react
        case 1: self = .remove
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .react: return 0
        case .remove: return 1
        }
      }

    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _author: String? = nil
    fileprivate var _emoji: String? = nil
    fileprivate var _action: SessionProtos_DataMessage.Reaction.Action? = nil
  }

  struct OpenGroupInvitation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    /// @required
    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: String? = nil
    fileprivate var _name: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SessionProtos_DataMessage.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

extension SessionProtos_DataMessage.Reaction.Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_ReceiptMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_ReceiptMessage.TypeEnum {
    get {return _type ?? .delivery}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case delivery // = 0
    case read // = 1

    init() {
      self = .delivery
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delivery
      case 1: self = .read
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .delivery: return 0
      case .read: return 1
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_ReceiptMessage.TypeEnum? = nil
}

#if swift(>=4.2)

extension SessionProtos_ReceiptMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_AttachmentPointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var thumbnail: Data {
    get {return _thumbnail ?? Data()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {self._thumbnail = nil}

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case voiceMessage // = 1

    init() {
      self = .voiceMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .voiceMessage
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .voiceMessage: return 1
      }
    }

  }

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _size: UInt32? = nil
  fileprivate var _thumbnail: Data? = nil
  fileprivate var _digest: Data? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _url: String? = nil
}

#if swift(>=4.2)

extension SessionProtos_AttachmentPointer.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_GroupUpdateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inviteMessage: SessionProtos_GroupUpdateInviteMessage {
    get {return _storage._inviteMessage ?? SessionProtos_GroupUpdateInviteMessage()}
    set {_uniqueStorage()._inviteMessage = newValue}
  }
  /// Returns true if `inviteMessage` has been explicitly set.
  var hasInviteMessage: Bool {return _storage._inviteMessage != nil}
  /// Clears the value of `inviteMessage`. Subsequent reads from it will return its default value.
  mutating func clearInviteMessage() {_uniqueStorage()._inviteMessage = nil}

  var infoChangeMessage: SessionProtos_GroupUpdateInfoChangeMessage {
    get {return _storage._infoChangeMessage ?? SessionProtos_GroupUpdateInfoChangeMessage()}
    set {_uniqueStorage()._infoChangeMessage = newValue}
  }
  /// Returns true if `infoChangeMessage` has been explicitly set.
  var hasInfoChangeMessage: Bool {return _storage._infoChangeMessage != nil}
  /// Clears the value of `infoChangeMessage`. Subsequent reads from it will return its default value.
  mutating func clearInfoChangeMessage() {_uniqueStorage()._infoChangeMessage = nil}

  var memberChangeMessage: SessionProtos_GroupUpdateMemberChangeMessage {
    get {return _storage._memberChangeMessage ?? SessionProtos_GroupUpdateMemberChangeMessage()}
    set {_uniqueStorage()._memberChangeMessage = newValue}
  }
  /// Returns true if `memberChangeMessage` has been explicitly set.
  var hasMemberChangeMessage: Bool {return _storage._memberChangeMessage != nil}
  /// Clears the value of `memberChangeMessage`. Subsequent reads from it will return its default value.
  mutating func clearMemberChangeMessage() {_uniqueStorage()._memberChangeMessage = nil}

  var promoteMessage: SessionProtos_GroupUpdatePromoteMessage {
    get {return _storage._promoteMessage ?? SessionProtos_GroupUpdatePromoteMessage()}
    set {_uniqueStorage()._promoteMessage = newValue}
  }
  /// Returns true if `promoteMessage` has been explicitly set.
  var hasPromoteMessage: Bool {return _storage._promoteMessage != nil}
  /// Clears the value of `promoteMessage`. Subsequent reads from it will return its default value.
  mutating func clearPromoteMessage() {_uniqueStorage()._promoteMessage = nil}

  var memberLeftMessage: SessionProtos_GroupUpdateMemberLeftMessage {
    get {return _storage._memberLeftMessage ?? SessionProtos_GroupUpdateMemberLeftMessage()}
    set {_uniqueStorage()._memberLeftMessage = newValue}
  }
  /// Returns true if `memberLeftMessage` has been explicitly set.
  var hasMemberLeftMessage: Bool {return _storage._memberLeftMessage != nil}
  /// Clears the value of `memberLeftMessage`. Subsequent reads from it will return its default value.
  mutating func clearMemberLeftMessage() {_uniqueStorage()._memberLeftMessage = nil}

  var inviteResponse: SessionProtos_GroupUpdateInviteResponseMessage {
    get {return _storage._inviteResponse ?? SessionProtos_GroupUpdateInviteResponseMessage()}
    set {_uniqueStorage()._inviteResponse = newValue}
  }
  /// Returns true if `inviteResponse` has been explicitly set.
  var hasInviteResponse: Bool {return _storage._inviteResponse != nil}
  /// Clears the value of `inviteResponse`. Subsequent reads from it will return its default value.
  mutating func clearInviteResponse() {_uniqueStorage()._inviteResponse = nil}

  var deleteMemberContent: SessionProtos_GroupUpdateDeleteMemberContentMessage {
    get {return _storage._deleteMemberContent ?? SessionProtos_GroupUpdateDeleteMemberContentMessage()}
    set {_uniqueStorage()._deleteMemberContent = newValue}
  }
  /// Returns true if `deleteMemberContent` has been explicitly set.
  var hasDeleteMemberContent: Bool {return _storage._deleteMemberContent != nil}
  /// Clears the value of `deleteMemberContent`. Subsequent reads from it will return its default value.
  mutating func clearDeleteMemberContent() {_uniqueStorage()._deleteMemberContent = nil}

  var memberLeftNotificationMessage: SessionProtos_GroupUpdateMemberLeftNotificationMessage {
    get {return _storage._memberLeftNotificationMessage ?? SessionProtos_GroupUpdateMemberLeftNotificationMessage()}
    set {_uniqueStorage()._memberLeftNotificationMessage = newValue}
  }
  /// Returns true if `memberLeftNotificationMessage` has been explicitly set.
  var hasMemberLeftNotificationMessage: Bool {return _storage._memberLeftNotificationMessage != nil}
  /// Clears the value of `memberLeftNotificationMessage`. Subsequent reads from it will return its default value.
  mutating func clearMemberLeftNotificationMessage() {_uniqueStorage()._memberLeftNotificationMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SessionProtos_GroupUpdateInviteMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var groupSessionID: String {
    get {return _groupSessionID ?? String()}
    set {_groupSessionID = newValue}
  }
  /// Returns true if `groupSessionID` has been explicitly set.
  var hasGroupSessionID: Bool {return self._groupSessionID != nil}
  /// Clears the value of `groupSessionID`. Subsequent reads from it will return its default value.
  mutating func clearGroupSessionID() {self._groupSessionID = nil}

  /// @required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// @required
  var memberAuthData: Data {
    get {return _memberAuthData ?? Data()}
    set {_memberAuthData = newValue}
  }
  /// Returns true if `memberAuthData` has been explicitly set.
  var hasMemberAuthData: Bool {return self._memberAuthData != nil}
  /// Clears the value of `memberAuthData`. Subsequent reads from it will return its default value.
  mutating func clearMemberAuthData() {self._memberAuthData = nil}

  /// @required
  var adminSignature: Data {
    get {return _adminSignature ?? Data()}
    set {_adminSignature = newValue}
  }
  /// Returns true if `adminSignature` has been explicitly set.
  var hasAdminSignature: Bool {return self._adminSignature != nil}
  /// Clears the value of `adminSignature`. Subsequent reads from it will return its default value.
  mutating func clearAdminSignature() {self._adminSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupSessionID: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _memberAuthData: Data? = nil
  fileprivate var _adminSignature: Data? = nil
}

struct SessionProtos_GroupUpdatePromoteMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var groupIdentitySeed: Data {
    get {return _groupIdentitySeed ?? Data()}
    set {_groupIdentitySeed = newValue}
  }
  /// Returns true if `groupIdentitySeed` has been explicitly set.
  var hasGroupIdentitySeed: Bool {return self._groupIdentitySeed != nil}
  /// Clears the value of `groupIdentitySeed`. Subsequent reads from it will return its default value.
  mutating func clearGroupIdentitySeed() {self._groupIdentitySeed = nil}

  /// @required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupIdentitySeed: Data? = nil
  fileprivate var _name: String? = nil
}

struct SessionProtos_GroupUpdateInfoChangeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_GroupUpdateInfoChangeMessage.TypeEnum {
    get {return _type ?? .name}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var updatedName: String {
    get {return _updatedName ?? String()}
    set {_updatedName = newValue}
  }
  /// Returns true if `updatedName` has been explicitly set.
  var hasUpdatedName: Bool {return self._updatedName != nil}
  /// Clears the value of `updatedName`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedName() {self._updatedName = nil}

  var updatedExpiration: UInt32 {
    get {return _updatedExpiration ?? 0}
    set {_updatedExpiration = newValue}
  }
  /// Returns true if `updatedExpiration` has been explicitly set.
  var hasUpdatedExpiration: Bool {return self._updatedExpiration != nil}
  /// Clears the value of `updatedExpiration`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedExpiration() {self._updatedExpiration = nil}

  /// @required
  var adminSignature: Data {
    get {return _adminSignature ?? Data()}
    set {_adminSignature = newValue}
  }
  /// Returns true if `adminSignature` has been explicitly set.
  var hasAdminSignature: Bool {return self._adminSignature != nil}
  /// Clears the value of `adminSignature`. Subsequent reads from it will return its default value.
  mutating func clearAdminSignature() {self._adminSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case name // = 1
    case avatar // = 2
    case disappearingMessages // = 3

    init() {
      self = .name
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .name
      case 2: self = .avatar
      case 3: self = .disappearingMessages
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .name: return 1
      case .avatar: return 2
      case .disappearingMessages: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_GroupUpdateInfoChangeMessage.TypeEnum? = nil
  fileprivate var _updatedName: String? = nil
  fileprivate var _updatedExpiration: UInt32? = nil
  fileprivate var _adminSignature: Data? = nil
}

#if swift(>=4.2)

extension SessionProtos_GroupUpdateInfoChangeMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_GroupUpdateMemberChangeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_GroupUpdateMemberChangeMessage.TypeEnum {
    get {return _type ?? .added}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var memberSessionIds: [String] = []

  var historyShared: Bool {
    get {return _historyShared ?? false}
    set {_historyShared = newValue}
  }
  /// Returns true if `historyShared` has been explicitly set.
  var hasHistoryShared: Bool {return self._historyShared != nil}
  /// Clears the value of `historyShared`. Subsequent reads from it will return its default value.
  mutating func clearHistoryShared() {self._historyShared = nil}

  /// @required
  var adminSignature: Data {
    get {return _adminSignature ?? Data()}
    set {_adminSignature = newValue}
  }
  /// Returns true if `adminSignature` has been explicitly set.
  var hasAdminSignature: Bool {return self._adminSignature != nil}
  /// Clears the value of `adminSignature`. Subsequent reads from it will return its default value.
  mutating func clearAdminSignature() {self._adminSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case added // = 1
    case removed // = 2
    case promoted // = 3

    init() {
      self = .added
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .added
      case 2: self = .removed
      case 3: self = .promoted
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .added: return 1
      case .removed: return 2
      case .promoted: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_GroupUpdateMemberChangeMessage.TypeEnum? = nil
  fileprivate var _historyShared: Bool? = nil
  fileprivate var _adminSignature: Data? = nil
}

#if swift(>=4.2)

extension SessionProtos_GroupUpdateMemberChangeMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// the pubkey of the member left is included as part of the closed group encryption logic (senderIdentity on desktop)
struct SessionProtos_GroupUpdateMemberLeftMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// the pubkey of the member left is included as part of the closed group encryption logic (senderIdentity on desktop)
struct SessionProtos_GroupUpdateMemberLeftNotificationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SessionProtos_GroupUpdateInviteResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var isApproved: Bool {
    get {return _isApproved ?? false}
    set {_isApproved = newValue}
  }
  /// Returns true if `isApproved` has been explicitly set.
  var hasIsApproved: Bool {return self._isApproved != nil}
  /// Clears the value of `isApproved`. Subsequent reads from it will return its default value.
  mutating func clearIsApproved() {self._isApproved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isApproved: Bool? = nil
}

struct SessionProtos_GroupUpdateDeleteMemberContentMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var memberSessionIds: [String] = []

  var messageHashes: [String] = []

  var adminSignature: Data {
    get {return _adminSignature ?? Data()}
    set {_adminSignature = newValue}
  }
  /// Returns true if `adminSignature` has been explicitly set.
  var hasAdminSignature: Bool {return self._adminSignature != nil}
  /// Clears the value of `adminSignature`. Subsequent reads from it will return its default value.
  mutating func clearAdminSignature() {self._adminSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adminSignature: Data? = nil
}

struct SessionProtos_ProProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// Opaque identifier of this proof produced by the Session Pro backend
  var genIndexHash: Data {
    get {return _genIndexHash ?? Data()}
    set {_genIndexHash = newValue}
  }
  /// Returns true if `genIndexHash` has been explicitly set.
  var hasGenIndexHash: Bool {return self._genIndexHash != nil}
  /// Clears the value of `genIndexHash`. Subsequent reads from it will return its default value.
  mutating func clearGenIndexHash() {self._genIndexHash = nil}

  /// Public key whose signatures is authorised to entitle messages with Session Pro
  var rotatingPublicKey: Data {
    get {return _rotatingPublicKey ?? Data()}
    set {_rotatingPublicKey = newValue}
  }
  /// Returns true if `rotatingPublicKey` has been explicitly set.
  var hasRotatingPublicKey: Bool {return self._rotatingPublicKey != nil}
  /// Clears the value of `rotatingPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearRotatingPublicKey() {self._rotatingPublicKey = nil}

  /// Epoch timestamps in milliseconds
  var expiryUnixTs: UInt64 {
    get {return _expiryUnixTs ?? 0}
    set {_expiryUnixTs = newValue}
  }
  /// Returns true if `expiryUnixTs` has been explicitly set.
  var hasExpiryUnixTs: Bool {return self._expiryUnixTs != nil}
  /// Clears the value of `expiryUnixTs`. Subsequent reads from it will return its default value.
  mutating func clearExpiryUnixTs() {self._expiryUnixTs = nil}

  /// Signature produced by the Session Pro Backend signing over the hash of the proof
  var sig: Data {
    get {return _sig ?? Data()}
    set {_sig = newValue}
  }
  /// Returns true if `sig` has been explicitly set.
  var hasSig: Bool {return self._sig != nil}
  /// Clears the value of `sig`. Subsequent reads from it will return its default value.
  mutating func clearSig() {self._sig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt32? = nil
  fileprivate var _genIndexHash: Data? = nil
  fileprivate var _rotatingPublicKey: Data? = nil
  fileprivate var _expiryUnixTs: UInt64? = nil
  fileprivate var _sig: Data? = nil
}

struct SessionProtos_ProMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: SessionProtos_ProProof {
    get {return _proof ?? SessionProtos_ProProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var profileBitset: UInt64 {
    get {return _profileBitset ?? 0}
    set {_profileBitset = newValue}
  }
  /// Returns true if `profileBitset` has been explicitly set.
  var hasProfileBitset: Bool {return self._profileBitset != nil}
  /// Clears the value of `profileBitset`. Subsequent reads from it will return its default value.
  mutating func clearProfileBitset() {self._profileBitset = nil}

  var msgBitset: UInt64 {
    get {return _msgBitset ?? 0}
    set {_msgBitset = newValue}
  }
  /// Returns true if `msgBitset` has been explicitly set.
  var hasMsgBitset: Bool {return self._msgBitset != nil}
  /// Clears the value of `msgBitset`. Subsequent reads from it will return its default value.
  mutating func clearMsgBitset() {self._msgBitset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proof: SessionProtos_ProProof? = nil
  fileprivate var _profileBitset: UInt64? = nil
  fileprivate var _msgBitset: UInt64? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SessionProtos_Envelope: @unchecked Sendable {}
extension SessionProtos_Envelope.TypeEnum: @unchecked Sendable {}
extension SessionProtos_TypingMessage: @unchecked Sendable {}
extension SessionProtos_TypingMessage.Action: @unchecked Sendable {}
extension SessionProtos_UnsendRequest: @unchecked Sendable {}
extension SessionProtos_MessageRequestResponse: @unchecked Sendable {}
extension SessionProtos_Content: @unchecked Sendable {}
extension SessionProtos_Content.ExpirationType: @unchecked Sendable {}
extension SessionProtos_CallMessage: @unchecked Sendable {}
extension SessionProtos_CallMessage.TypeEnum: @unchecked Sendable {}
extension SessionProtos_KeyPair: @unchecked Sendable {}
extension SessionProtos_DataExtractionNotification: @unchecked Sendable {}
extension SessionProtos_DataExtractionNotification.TypeEnum: @unchecked Sendable {}
extension SessionProtos_LokiProfile: @unchecked Sendable {}
extension SessionProtos_DataMessage: @unchecked Sendable {}
extension SessionProtos_DataMessage.Flags: @unchecked Sendable {}
extension SessionProtos_DataMessage.Quote: @unchecked Sendable {}
extension SessionProtos_DataMessage.Quote.QuotedAttachment: @unchecked Sendable {}
extension SessionProtos_DataMessage.Quote.QuotedAttachment.Flags: @unchecked Sendable {}
extension SessionProtos_DataMessage.Preview: @unchecked Sendable {}
extension SessionProtos_DataMessage.Reaction: @unchecked Sendable {}
extension SessionProtos_DataMessage.Reaction.Action: @unchecked Sendable {}
extension SessionProtos_DataMessage.OpenGroupInvitation: @unchecked Sendable {}
extension SessionProtos_ReceiptMessage: @unchecked Sendable {}
extension SessionProtos_ReceiptMessage.TypeEnum: @unchecked Sendable {}
extension SessionProtos_AttachmentPointer: @unchecked Sendable {}
extension SessionProtos_AttachmentPointer.Flags: @unchecked Sendable {}
extension SessionProtos_GroupUpdateMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateInviteMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdatePromoteMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateInfoChangeMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateInfoChangeMessage.TypeEnum: @unchecked Sendable {}
extension SessionProtos_GroupUpdateMemberChangeMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateMemberChangeMessage.TypeEnum: @unchecked Sendable {}
extension SessionProtos_GroupUpdateMemberLeftMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateMemberLeftNotificationMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateInviteResponseMessage: @unchecked Sendable {}
extension SessionProtos_GroupUpdateDeleteMemberContentMessage: @unchecked Sendable {}
extension SessionProtos_ProProof: @unchecked Sendable {}
extension SessionProtos_ProMessage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SessionProtos"

extension SessionProtos_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    7: .same(proto: "sourceDevice"),
    5: .same(proto: "timestamp"),
    8: .same(proto: "content"),
    10: .same(proto: "serverTimestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._timestamp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._sourceDevice) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._content) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sourceDevice {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_Envelope, rhs: SessionProtos_Envelope) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._source != rhs._source {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._content != rhs._content {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "SESSION_MESSAGE"),
    7: .same(proto: "CLOSED_GROUP_MESSAGE"),
  ]
}

extension SessionProtos_TypingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "action"),
  ]

  public var isInitialized: Bool {
    if self._timestamp == nil {return false}
    if self._action == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_TypingMessage, rhs: SessionProtos_TypingMessage) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_TypingMessage.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARTED"),
    1: .same(proto: "STOPPED"),
  ]
}

extension SessionProtos_UnsendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "author"),
  ]

  public var isInitialized: Bool {
    if self._timestamp == nil {return false}
    if self._author == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_UnsendRequest, rhs: SessionProtos_UnsendRequest) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._author != rhs._author {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_MessageRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isApproved"),
    2: .same(proto: "profileKey"),
    3: .same(proto: "profile"),
  ]

  public var isInitialized: Bool {
    if self._isApproved == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isApproved) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isApproved {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_MessageRequestResponse, rhs: SessionProtos_MessageRequestResponse) -> Bool {
    if lhs._isApproved != rhs._isApproved {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataMessage"),
    3: .same(proto: "callMessage"),
    5: .same(proto: "receiptMessage"),
    6: .same(proto: "typingMessage"),
    8: .same(proto: "dataExtractionNotification"),
    9: .same(proto: "unsendRequest"),
    10: .same(proto: "messageRequestResponse"),
    12: .same(proto: "expirationType"),
    13: .same(proto: "expirationTimer"),
    15: .same(proto: "sigTimestamp"),
    16: .same(proto: "proMessage"),
    17: .same(proto: "proSigForCommunityMessageOnly"),
  ]

  fileprivate class _StorageClass {
    var _dataMessage: SessionProtos_DataMessage? = nil
    var _callMessage: SessionProtos_CallMessage? = nil
    var _receiptMessage: SessionProtos_ReceiptMessage? = nil
    var _typingMessage: SessionProtos_TypingMessage? = nil
    var _dataExtractionNotification: SessionProtos_DataExtractionNotification? = nil
    var _unsendRequest: SessionProtos_UnsendRequest? = nil
    var _messageRequestResponse: SessionProtos_MessageRequestResponse? = nil
    var _expirationType: SessionProtos_Content.ExpirationType? = nil
    var _expirationTimer: UInt32? = nil
    var _sigTimestamp: UInt64? = nil
    var _proMessage: SessionProtos_ProMessage? = nil
    var _proSigForCommunityMessageOnly: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dataMessage = source._dataMessage
      _callMessage = source._callMessage
      _receiptMessage = source._receiptMessage
      _typingMessage = source._typingMessage
      _dataExtractionNotification = source._dataExtractionNotification
      _unsendRequest = source._unsendRequest
      _messageRequestResponse = source._messageRequestResponse
      _expirationType = source._expirationType
      _expirationTimer = source._expirationTimer
      _sigTimestamp = source._sigTimestamp
      _proMessage = source._proMessage
      _proSigForCommunityMessageOnly = source._proSigForCommunityMessageOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dataMessage, !v.isInitialized {return false}
      if let v = _storage._callMessage, !v.isInitialized {return false}
      if let v = _storage._receiptMessage, !v.isInitialized {return false}
      if let v = _storage._typingMessage, !v.isInitialized {return false}
      if let v = _storage._dataExtractionNotification, !v.isInitialized {return false}
      if let v = _storage._unsendRequest, !v.isInitialized {return false}
      if let v = _storage._messageRequestResponse, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dataMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._callMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._receiptMessage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._typingMessage) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dataExtractionNotification) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._unsendRequest) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._messageRequestResponse) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._expirationType) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._expirationTimer) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._sigTimestamp) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._proMessage) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._proSigForCommunityMessageOnly) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dataMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._callMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._receiptMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._typingMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._dataExtractionNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._unsendRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._messageRequestResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._expirationType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._expirationTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._sigTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._proMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._proSigForCommunityMessageOnly {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_Content, rhs: SessionProtos_Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dataMessage != rhs_storage._dataMessage {return false}
        if _storage._callMessage != rhs_storage._callMessage {return false}
        if _storage._receiptMessage != rhs_storage._receiptMessage {return false}
        if _storage._typingMessage != rhs_storage._typingMessage {return false}
        if _storage._dataExtractionNotification != rhs_storage._dataExtractionNotification {return false}
        if _storage._unsendRequest != rhs_storage._unsendRequest {return false}
        if _storage._messageRequestResponse != rhs_storage._messageRequestResponse {return false}
        if _storage._expirationType != rhs_storage._expirationType {return false}
        if _storage._expirationTimer != rhs_storage._expirationTimer {return false}
        if _storage._sigTimestamp != rhs_storage._sigTimestamp {return false}
        if _storage._proMessage != rhs_storage._proMessage {return false}
        if _storage._proSigForCommunityMessageOnly != rhs_storage._proSigForCommunityMessageOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_Content.ExpirationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DELETE_AFTER_READ"),
    2: .same(proto: "DELETE_AFTER_SEND"),
  ]
}

extension SessionProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "sdps"),
    3: .same(proto: "sdpMLineIndexes"),
    4: .same(proto: "sdpMids"),
    5: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._uuid == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sdps) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.sdpMlineIndexes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.sdpMids) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.sdps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sdps, fieldNumber: 2)
    }
    if !self.sdpMlineIndexes.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.sdpMlineIndexes, fieldNumber: 3)
    }
    if !self.sdpMids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sdpMids, fieldNumber: 4)
    }
    try { if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage, rhs: SessionProtos_CallMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.sdps != rhs.sdps {return false}
    if lhs.sdpMlineIndexes != rhs.sdpMlineIndexes {return false}
    if lhs.sdpMids != rhs.sdpMids {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OFFER"),
    2: .same(proto: "ANSWER"),
    3: .same(proto: "PROVISIONAL_ANSWER"),
    4: .same(proto: "ICE_CANDIDATES"),
    5: .same(proto: "END_CALL"),
    6: .same(proto: "PRE_OFFER"),
  ]
}

extension SessionProtos_KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  public var isInitialized: Bool {
    if self._publicKey == nil {return false}
    if self._privateKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._privateKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_KeyPair, rhs: SessionProtos_KeyPair) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataExtractionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataExtractionNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataExtractionNotification, rhs: SessionProtos_DataExtractionNotification) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataExtractionNotification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SCREENSHOT"),
    2: .same(proto: "MEDIA_SAVED"),
  ]
}

extension SessionProtos_LokiProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LokiProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "displayName"),
    2: .same(proto: "profilePicture"),
    3: .same(proto: "lastUpdateSeconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._profilePicture) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._lastUpdateSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profilePicture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastUpdateSeconds {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_LokiProfile, rhs: SessionProtos_LokiProfile) -> Bool {
    if lhs._displayName != rhs._displayName {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._lastUpdateSeconds != rhs._lastUpdateSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "attachments"),
    4: .same(proto: "flags"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "quote"),
    10: .same(proto: "preview"),
    11: .same(proto: "reaction"),
    101: .same(proto: "profile"),
    102: .same(proto: "openGroupInvitation"),
    105: .same(proto: "syncTarget"),
    106: .same(proto: "blocksCommunityMessageRequests"),
    120: .same(proto: "groupUpdateMessage"),
  ]

  fileprivate class _StorageClass {
    var _body: String? = nil
    var _attachments: [SessionProtos_AttachmentPointer] = []
    var _flags: UInt32? = nil
    var _profileKey: Data? = nil
    var _timestamp: UInt64? = nil
    var _quote: SessionProtos_DataMessage.Quote? = nil
    var _preview: [SessionProtos_DataMessage.Preview] = []
    var _reaction: SessionProtos_DataMessage.Reaction? = nil
    var _profile: SessionProtos_LokiProfile? = nil
    var _openGroupInvitation: SessionProtos_DataMessage.OpenGroupInvitation? = nil
    var _syncTarget: String? = nil
    var _blocksCommunityMessageRequests: Bool? = nil
    var _groupUpdateMessage: SessionProtos_GroupUpdateMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _attachments = source._attachments
      _flags = source._flags
      _profileKey = source._profileKey
      _timestamp = source._timestamp
      _quote = source._quote
      _preview = source._preview
      _reaction = source._reaction
      _profile = source._profile
      _openGroupInvitation = source._openGroupInvitation
      _syncTarget = source._syncTarget
      _blocksCommunityMessageRequests = source._blocksCommunityMessageRequests
      _groupUpdateMessage = source._groupUpdateMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._attachments) {return false}
      if let v = _storage._quote, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._preview) {return false}
      if let v = _storage._reaction, !v.isInitialized {return false}
      if let v = _storage._openGroupInvitation, !v.isInitialized {return false}
      if let v = _storage._groupUpdateMessage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._body) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._preview) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._reaction) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._profile) }()
        case 102: try { try decoder.decodeSingularMessageField(value: &_storage._openGroupInvitation) }()
        case 105: try { try decoder.decodeSingularStringField(value: &_storage._syncTarget) }()
        case 106: try { try decoder.decodeSingularBoolField(value: &_storage._blocksCommunityMessageRequests) }()
        case 120: try { try decoder.decodeSingularMessageField(value: &_storage._groupUpdateMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._body {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 2)
      }
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._preview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preview, fieldNumber: 10)
      }
      try { if let v = _storage._reaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      try { if let v = _storage._openGroupInvitation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      } }()
      try { if let v = _storage._syncTarget {
        try visitor.visitSingularStringField(value: v, fieldNumber: 105)
      } }()
      try { if let v = _storage._blocksCommunityMessageRequests {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 106)
      } }()
      try { if let v = _storage._groupUpdateMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage, rhs: SessionProtos_DataMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._reaction != rhs_storage._reaction {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._openGroupInvitation != rhs_storage._openGroupInvitation {return false}
        if _storage._syncTarget != rhs_storage._syncTarget {return false}
        if _storage._blocksCommunityMessageRequests != rhs_storage._blocksCommunityMessageRequests {return false}
        if _storage._groupUpdateMessage != rhs_storage._groupUpdateMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "EXPIRATION_TIMER_UPDATE"),
  ]
}

extension SessionProtos_DataMessage.Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._author == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attachments) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Quote, rhs: SessionProtos_DataMessage.Quote) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._author != rhs._author {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
    4: .same(proto: "flags"),
  ]

  public var isInitialized: Bool {
    if let v = self._thumbnail, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Quote.QuotedAttachment, rhs: SessionProtos_DataMessage.Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension SessionProtos_DataMessage.Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".Preview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if let v = self._image, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Preview, rhs: SessionProtos_DataMessage.Preview) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .same(proto: "emoji"),
    4: .same(proto: "action"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._author == nil {return false}
    if self._action == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Reaction, rhs: SessionProtos_DataMessage.Reaction) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._author != rhs._author {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Reaction.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REACT"),
    1: .same(proto: "REMOVE"),
  ]
}

extension SessionProtos_DataMessage.OpenGroupInvitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".OpenGroupInvitation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    3: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.OpenGroupInvitation, rhs: SessionProtos_DataMessage.OpenGroupInvitation) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ReceiptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.timestamp.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ReceiptMessage, rhs: SessionProtos_ReceiptMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ReceiptMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERY"),
    1: .same(proto: "READ"),
  ]
}

extension SessionProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contentType"),
    3: .same(proto: "key"),
    4: .same(proto: "size"),
    5: .same(proto: "thumbnail"),
    6: .same(proto: "digest"),
    7: .same(proto: "fileName"),
    8: .same(proto: "flags"),
    9: .same(proto: "width"),
    10: .same(proto: "height"),
    11: .same(proto: "caption"),
    101: .same(proto: "url"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._thumbnail) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_AttachmentPointer, rhs: SessionProtos_AttachmentPointer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs._size != rhs._size {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_AttachmentPointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension SessionProtos_GroupUpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviteMessage"),
    2: .same(proto: "infoChangeMessage"),
    3: .same(proto: "memberChangeMessage"),
    4: .same(proto: "promoteMessage"),
    5: .same(proto: "memberLeftMessage"),
    6: .same(proto: "inviteResponse"),
    7: .same(proto: "deleteMemberContent"),
    8: .same(proto: "memberLeftNotificationMessage"),
  ]

  fileprivate class _StorageClass {
    var _inviteMessage: SessionProtos_GroupUpdateInviteMessage? = nil
    var _infoChangeMessage: SessionProtos_GroupUpdateInfoChangeMessage? = nil
    var _memberChangeMessage: SessionProtos_GroupUpdateMemberChangeMessage? = nil
    var _promoteMessage: SessionProtos_GroupUpdatePromoteMessage? = nil
    var _memberLeftMessage: SessionProtos_GroupUpdateMemberLeftMessage? = nil
    var _inviteResponse: SessionProtos_GroupUpdateInviteResponseMessage? = nil
    var _deleteMemberContent: SessionProtos_GroupUpdateDeleteMemberContentMessage? = nil
    var _memberLeftNotificationMessage: SessionProtos_GroupUpdateMemberLeftNotificationMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inviteMessage = source._inviteMessage
      _infoChangeMessage = source._infoChangeMessage
      _memberChangeMessage = source._memberChangeMessage
      _promoteMessage = source._promoteMessage
      _memberLeftMessage = source._memberLeftMessage
      _inviteResponse = source._inviteResponse
      _deleteMemberContent = source._deleteMemberContent
      _memberLeftNotificationMessage = source._memberLeftNotificationMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._inviteMessage, !v.isInitialized {return false}
      if let v = _storage._infoChangeMessage, !v.isInitialized {return false}
      if let v = _storage._memberChangeMessage, !v.isInitialized {return false}
      if let v = _storage._promoteMessage, !v.isInitialized {return false}
      if let v = _storage._inviteResponse, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._inviteMessage) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._infoChangeMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memberChangeMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._promoteMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._memberLeftMessage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._inviteResponse) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deleteMemberContent) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._memberLeftNotificationMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._inviteMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._infoChangeMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memberChangeMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._promoteMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._memberLeftMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._inviteResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._deleteMemberContent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._memberLeftNotificationMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateMessage, rhs: SessionProtos_GroupUpdateMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inviteMessage != rhs_storage._inviteMessage {return false}
        if _storage._infoChangeMessage != rhs_storage._infoChangeMessage {return false}
        if _storage._memberChangeMessage != rhs_storage._memberChangeMessage {return false}
        if _storage._promoteMessage != rhs_storage._promoteMessage {return false}
        if _storage._memberLeftMessage != rhs_storage._memberLeftMessage {return false}
        if _storage._inviteResponse != rhs_storage._inviteResponse {return false}
        if _storage._deleteMemberContent != rhs_storage._deleteMemberContent {return false}
        if _storage._memberLeftNotificationMessage != rhs_storage._memberLeftNotificationMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateInviteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateInviteMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupSessionId"),
    2: .same(proto: "name"),
    3: .same(proto: "memberAuthData"),
    4: .same(proto: "adminSignature"),
  ]

  public var isInitialized: Bool {
    if self._groupSessionID == nil {return false}
    if self._name == nil {return false}
    if self._memberAuthData == nil {return false}
    if self._adminSignature == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._groupSessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._memberAuthData) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._adminSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupSessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memberAuthData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._adminSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateInviteMessage, rhs: SessionProtos_GroupUpdateInviteMessage) -> Bool {
    if lhs._groupSessionID != rhs._groupSessionID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._memberAuthData != rhs._memberAuthData {return false}
    if lhs._adminSignature != rhs._adminSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdatePromoteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdatePromoteMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupIdentitySeed"),
    2: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._groupIdentitySeed == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._groupIdentitySeed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupIdentitySeed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdatePromoteMessage, rhs: SessionProtos_GroupUpdatePromoteMessage) -> Bool {
    if lhs._groupIdentitySeed != rhs._groupIdentitySeed {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateInfoChangeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateInfoChangeMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "updatedName"),
    3: .same(proto: "updatedExpiration"),
    4: .same(proto: "adminSignature"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._adminSignature == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._updatedName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._updatedExpiration) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._adminSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updatedExpiration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._adminSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateInfoChangeMessage, rhs: SessionProtos_GroupUpdateInfoChangeMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._updatedName != rhs._updatedName {return false}
    if lhs._updatedExpiration != rhs._updatedExpiration {return false}
    if lhs._adminSignature != rhs._adminSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateInfoChangeMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NAME"),
    2: .same(proto: "AVATAR"),
    3: .same(proto: "DISAPPEARING_MESSAGES"),
  ]
}

extension SessionProtos_GroupUpdateMemberChangeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateMemberChangeMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "memberSessionIds"),
    3: .same(proto: "historyShared"),
    4: .same(proto: "adminSignature"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._adminSignature == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.memberSessionIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._historyShared) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._adminSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.memberSessionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberSessionIds, fieldNumber: 2)
    }
    try { if let v = self._historyShared {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._adminSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateMemberChangeMessage, rhs: SessionProtos_GroupUpdateMemberChangeMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.memberSessionIds != rhs.memberSessionIds {return false}
    if lhs._historyShared != rhs._historyShared {return false}
    if lhs._adminSignature != rhs._adminSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateMemberChangeMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ADDED"),
    2: .same(proto: "REMOVED"),
    3: .same(proto: "PROMOTED"),
  ]
}

extension SessionProtos_GroupUpdateMemberLeftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateMemberLeftMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateMemberLeftMessage, rhs: SessionProtos_GroupUpdateMemberLeftMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateMemberLeftNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateMemberLeftNotificationMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateMemberLeftNotificationMessage, rhs: SessionProtos_GroupUpdateMemberLeftNotificationMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateInviteResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateInviteResponseMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isApproved"),
  ]

  public var isInitialized: Bool {
    if self._isApproved == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isApproved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isApproved {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateInviteResponseMessage, rhs: SessionProtos_GroupUpdateInviteResponseMessage) -> Bool {
    if lhs._isApproved != rhs._isApproved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupUpdateDeleteMemberContentMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUpdateDeleteMemberContentMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memberSessionIds"),
    2: .same(proto: "messageHashes"),
    3: .same(proto: "adminSignature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.memberSessionIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.messageHashes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._adminSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.memberSessionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberSessionIds, fieldNumber: 1)
    }
    if !self.messageHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageHashes, fieldNumber: 2)
    }
    try { if let v = self._adminSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupUpdateDeleteMemberContentMessage, rhs: SessionProtos_GroupUpdateDeleteMemberContentMessage) -> Bool {
    if lhs.memberSessionIds != rhs.memberSessionIds {return false}
    if lhs.messageHashes != rhs.messageHashes {return false}
    if lhs._adminSignature != rhs._adminSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ProProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "genIndexHash"),
    3: .same(proto: "rotatingPublicKey"),
    4: .same(proto: "expiryUnixTs"),
    5: .same(proto: "sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._genIndexHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._rotatingPublicKey) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._expiryUnixTs) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._sig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._genIndexHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rotatingPublicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expiryUnixTs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sig {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ProProof, rhs: SessionProtos_ProProof) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._genIndexHash != rhs._genIndexHash {return false}
    if lhs._rotatingPublicKey != rhs._rotatingPublicKey {return false}
    if lhs._expiryUnixTs != rhs._expiryUnixTs {return false}
    if lhs._sig != rhs._sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ProMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .same(proto: "profileBitset"),
    3: .same(proto: "msgBitset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._profileBitset) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._msgBitset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._profileBitset {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._msgBitset {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ProMessage, rhs: SessionProtos_ProMessage) -> Bool {
    if lhs._proof != rhs._proof {return false}
    if lhs._profileBitset != rhs._profileBitset {return false}
    if lhs._msgBitset != rhs._msgBitset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
